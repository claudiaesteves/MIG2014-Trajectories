\section{Discussion}
\label{sec:discussion}

\textbf{Convergence}
The convergence of this algorithm depends mostly on how many entry and exit points are contained in the patch. The bigger the number, the higher the density will be, making it harder for the algorithm to converge to a solution.

There is an important limitation to be noted. When there are two boundary control points who are closer than our collision threshold, the harder it will be for the trajectories to converge, since the only way to find a collision free trajectory would be moving those fixed boundary control points (which is forbidden). A fix for that could be a better random generation of entry and exit points so they start in collision free positions. The problem will remain, nonetheless, when the input is defined by already created adjacent patches. Furthermore, two control points near the corners may have a repulsion force that forces one of them to go outside boundaries, for those cases, we have to either tell the algorithm to skip them (since there is no way to solve the collision) or let one of them go out of boundaries. For this implementation, the latter was decided for simplicity. 




\textbf{Solely Spatial Movement of Control Points}
In this paper, mostly spatial corrections to the trajectories of the agents are used. For some scenarios, moving the point in space coordinates may not be the best way to go, since it could provoke the control point to try moving outside of the patch boundaries or make a huge change in the agent's speed.   

Some collisions may be avoided just by changing the time in one of the two movable control points of a segment, thus making the agent move faster or slower without modifying the spatial trajectory. This would solve the problem of going out of the boundaries, but we have to be careful on how we change the time if we don't want to produce an unrealistic change in velocity.  We also have to be careful that trajectories can never go backwards in time. 


\textbf{Obstacles}
Earlier in this paper, it is mentioned that a patch may have static agents, called obstacles. The way of incorporating obstacles, it is still being discussed. For a small number of obstacles, we can consider them as another agent, and incorporate them into the algorithm with the extra condition that they can never be moved. The problem that arises is that obstacles must be well placed. When two obstacles are close enough that they form a tunnel for one initial trajectory, the movable control point will start looping going from one obstacle to another, unable to find a collision free trajectory. A possible solution for this, may be grouping the obstacles that are close to one another and consider them as a bigger obstacle. However, this would quickly start occupying the area of the patch. For that reason, a better technique for dealing with a dense number of obstacles must be developed. 

\textbf{Quality of motion}
By visual inspection the quality of motion in our approach is better than the method used by Yersin et al. \cite{Yersin:2009}.\memo{we already say this comparison to yersin in the results section} There are several methods that can be used to quantify quality of motion in crowds. These include \note{(=====================)}. We plan to use one or more of these methods to assess the quality of our motion in the future.

