\section{Discussion}
\label{sec:discussion}

\textbf{Convergence}
The convergence of this algorithm, depends mostly on number of agents required in the virtual scene; large numbers of agents lead to long convergence time as well as the possibility the algorithm will not converge and the patch generation will fail.
Convergence failure can occur if at least two boundary control points are closer to the minimum allowed threshold $\alpha$ (Section~\ref{sec:method:remove-collisions}) at the same exact moment in time; this is by definition a convergence failure since \emph{boundary control points cannot be moved}.
If on the other hand, the boundary control points differ slightly in time, the algorithm will converge but with a high probability of generating agents with unrealistic speeds.

% There is an important limitation to be noted. 
% 
% A problem arises when two boundary control points that are closer than our collision threshold. If the points are also at exactly the same time the algorithm will not converge, since the only way to remove this collision is to move the boundary control points (which is forbidden). If the boundary control points are close in time collisions can be avoided, but may require the agents to move at unrealistic speeds.s

 Furthermore, two control points near the corners may have a repulsion force that pushes one of them to go outside the patch's boundaries.
For these cases, two approaches can be taken; either ignore these two points or let one of the two points leave the bounds of the patch.
%  we have to either tell the algorithm to skip them (since there is no way to solve the collision) or let one of them go out of bounds.
 For this implementation, the latter was decided due to its simplicity.
 
 So this leads to one important comment; given bad input (i.e., patches) the algorithm will behave badly resulting into bad trajectories.
 Therefore, we are currently looking into approaches of generating patches that will guarantee well behaved trajectories (defining well behaved trajectories is also an interesting problem).

% There may be better ways to deal with these problems, but no matter what the algorithm for computing these trajectories is, if the input to the patch is bad, the trajectories will be bad. So in the future we will look at generating input to the patch that does not have these problems.

\textbf{ Spatial Movement of Control Points}
In this paper, mostly spatial corrections to the trajectories of the agents are used. For some scenarios, moving the point in space coordinates may not be the best way to go, since it could provoke the control point to try moving outside of the patch boundaries or make a huge change in the agent's speed.   

Some collisions may be avoided just by changing the time in one of the two movable control points of a segment, thus making the agent move faster or slower without modifying the spatial trajectory. This would solve the problem of going out of the boundaries, but we have to be careful on how we change the time if we don't want to produce an unrealistic change in velocity.  We also have to be careful that trajectories can never go backwards in time. 


\textbf{Obstacles}
Earlier in this paper, it is mentioned that a patch may have static agents, called obstacles. The way of incorporating obstacles is still being discussed. For a small number of obstacles, they can be considered as special agents that do not move. The problem that arises is that obstacles must be well placed. When a trajectory travels between two obstacles it can cause an infinite loop. The trajectory will oscillate between the obstacles, but the collision will never be resolved. A possible solution for this, may be grouping the obstacles that are close to one another into a bigger obstacle. However, this would quickly start occupying the area of the patch. For that reason, a better technique for dealing with a dense number of obstacles must be developed. 

\textbf{Quality of Motion}

The quality of motion was not measured for this paper other than by visual inspection. However there are several methods that can be used to quantify quality of motion in crowds. These include \note{(=====================)}. We plan to use one or more of these methods to assess the quality of our motion in the future.