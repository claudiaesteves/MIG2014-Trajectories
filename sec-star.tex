\section{State of the Art}
\label{sec:star}

Most often, virtual environments are populated based on crowd simulation approaches~\cite{ThalmannBook:2013}. An ambient crowd is generated from a large set of moving characters, mainly walking characters. Recent efforts in crowd simulation have enabled dealing with great performances ~\cite{PettreCAVW:2006,Treuille:2006}, high densities~\cite{Narain:2009} or controllable crowds~\cite{Guy:2009}. There has been a lot of effort to develop velocity-based approaches~\cite{Paris:2007,VanDenBerg:2008} which display much more smooth and realistic locomotion trajectories, especially thanks to anticipatory adaptation to avoid collisions between characters. \note{Nevertheless, \dots}

Simulation-based techniques are ideal to create an ambient crowd for large environments. Several problems are recurrent with such approaches: a) crowd simulation is computation demanding, crowd size is severly limited for interactive applications on light computers; b) simulation is based on simplistic behaviours (e.g. walk, avoid collisions, etc.), it is difficult to show diverse and rich crowds based on classical crowd simulation algorithms; c) crowd simulation is prone to animation artifacts or deadlock situations, it is impossible to guarantee animation quality. 

Example-based approaches attempt to solve the limitations on animation quality. The key idea of this approaches is that agents behave accordingly to set of existing example trajectories~\cite{Lerner:2007,Ju:2010,Charalambous:2014}. Locally, trajectories are necessarily of good quality, because they reproduce recorded ones. However, such approaches raise other difficulties: it is difficult to guarantee that the database of examples will cover all the required content, it can be difficult to control behaviors and interactions displayed by characters if the database content is not carefully selected. Finally, those approaches are also computationally demanding.

To solve both performances as well as quality issues, crowd patches were introduced in~\cite{Yersin:2009}. The key idea is to generate an ambient moving crowd from a set of interconnected patches. Each patch is a kind of 3D animated texture element, which records the trajectories of several moving characters. Trajectories are periodic in time, so that the crowd motion can be played endlessly. Trajectories boundary conditions, at the geometrical limits of patches are controlled to be able to connect together to patches, with characters moving from one patch to another. Thus, a crowd animated from a set of patches have a seamless motion, patches limit cannot be easily detected. The boundary conditions are all registered into {\it patterns}, which are sort of gates for patches with a set of spacetime input/output points. Please refer to the Yersin's paper for details. 

Nevertheless, using the crowd patches approach, it is important to work with a limited set of patters to enable easily connecting various patches. As a result, it is important to be able to compose a patch by starting from a set of patterns, and to deduce internal trajectories of patches from the set of bounday conditions set by patterns. As a result, we need to compute trajectories for characters that pass through a given set of spatiotemporal waypoints (not that we consider 2D trajectories for characters global motion here). This problem is difficult. Indeed, generally, steering techniques for characters consider spatial goals, but does not consider the time a character should reach its waypoint. Dedicated techniques are required. 

Yersin suggests using an adapted Helbing technique to compute internal trajectories~\cite{Helbing:2005}. The key idea is to connect input/output points together with linear trajectories, to model characters as particles attracted by a goal moving along one of these linear trajectories, combined with repulsion forces to avoid collision. One problem with this approach is limited density level, as well as the level of quality of trajectories: they suffer the usual drawbacks of Helbing's generated trajectories, i.e., lack of anticipation, which result into non natural local avoidance maneuvers. 

Compared to previous techniques to compute internal trajectories, we suggest formulating the problem of computing internal trajectories as an optimization problem. First, we suggest optimizing the way input and output points are connected. Especially, as waypoints are defined in space and time, we connect them trying to get some {\it good} walking speed (close to the average human walking speed). Indeed, characters moving too slow or too fast are visually evident artifacts. Second, after having connected waypoints with linear trajectories, we deform them to remove possible collisions. We do this through an iterative process trying to remove collisions with as limited as possible changes to the initial trajectories. We show improvements in the quality of results as compared to the original work by Yersin et al. 

\julien{Would be nice to add reference and comparison with the rule based techinique. } \panayiotis{Completely agree with that ... }
\claudia{I did not copied all the coments remaining in this Section. See google docs.}

