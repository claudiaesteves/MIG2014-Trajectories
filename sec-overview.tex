\section{Methodology}
\label{sec:method}

%%----------------------------------------------------------------
%% Overview Figure
%%----------------------------------------------------------------
\begin{figure*}[t]
	\begin{center}
	\includegraphics[width=0.9\linewidth]{./images/overview-hd.png}
% 	\includegraphics[height=4cm]{./images/patches-empty-patch-with-pattern.png}
% 	\includegraphics[height=4cm]{./images/patches-connected-patch.png}
% 	\includegraphics[height=4cm]{./images/patches-collision-free-patch.png}
% 	\includegraphics[height=4cm]{./images/patches-smoothed-patch.png}
	\caption{
		\textbf{Overview} Input and output points in a patch's patterns are initially connected and subsequently modified and smoothed out to be collision free.
	}
	\label{fig:overview}
	\end{center}
\end{figure*}
%%----------------------------------------------------------------
%% Overview Figure
%%----------------------------------------------------------------

\note{Overview: remind definitions on crowd patches: patch, pattern, spatiotemporal waypoints (boundary conditions: input, output, initial states // boundary conditions should be strictly enforced. Movable control points), period of time \dots}

\note{Starting Definitions:}

\begin{description}

\item[Patch]{
A patch is a set $\{ A, \pi, D, S\}$ where $A$ is a geometrical area with a convex polygonal shape, $\pi$ the period of time of the animation and $D$ and $S$ are the sets of dynamic and static objects, respectively.
These last two sets may be empty in case of an empty patch.
}

\item[Static obstacles]{
Static objects are simple obstacles whose geometry is fully contained inside the patch.
}

\item[Dynamic objects]{
Dynamic objects are animated; i.e., they are moving in time according to a set of trajectories $T$.
}

\end{description}

We define a {\bf trajectory} inside a patch as a function going from time to position, more specifically from the subset $[ 0,\pi ]$ to $A$:$ \tau:[t_1,t_2]\rightarrow A, \hspace{0.3cm} 0 \leq t_1 < t_2 \leq \pi$.
We represent a trajectory as a list of control points connected by segments. 
\note{THIS I A LITTLE BIT CONFUSING}

A {\bf control point} is a point in space and time $\mathbf{cp} = \{\mathbf{a}_{cp}, t_{cp}\}$. All control points in a trajectory can either be boundary or movable ones. Boundary control points serve as entry and exit points to the patch and cannot be moved, added or deleted. Movable control points can be moved, added, or removed from the trajectory as long as they do not violate the constraints of the patch; i.e., their positions $\mathbf{a}_{cp}$ must lie inside area $A$ and their time $t_{cp}$ must be between $t_1$ and $t_2$.

A {\bf segment} is a straight line connecting two control points in a specific order. Since these are unidirectional lines in space-time, it is important to remember that they are not allowed to go backwards in time.

There are two categories of dynamic objects: endogenous and exogenous agents. {\bf Endogenous agents} remain inside $A$ for the total period of time $\pi$. In order to achieve periodicity for the animation, they are associated with a trajectory $\tau : [0,\pi] \leftarrow A$, such that it respects the periodicity condition: the position at the start and at the end of the animation must be the same, i.e. \mbox{$\tau (0) = \tau (\pi)$}.\\
{\bf Exogenous agents} go outside $A$. They enter the patch at time $t_{initial}$ and position $a_{initial}$, and they exit at time $t_{final}$ and position $a_{final}$. For each agent we associate a sequence of $n \ge 1$ trajectories $\{ \tau_1, \tau_2, \dots, \tau_n\}$. Sequences may have only one trajectory, but some agents require additional trajectories in order to satisfy speed and time constraints. The following conditions must be respected in each sequence of trajectories associated with an exogenous agent:

\begin{itemize}

\item{$a_{initial}$ and $a_{final}$ must be points in the border of $A$. Otherwise, they couldn't be exogenous agents.}

\item{If the sequence is composed by more than one trajectory, for each two contiguous trajectories, the following must be true to ensure continuity: $\tau_i(\pi) = \tau_{i_{next}}(0)$.}

\end{itemize}

Note that the second condition implicitly implies that in sequences with multiple trajectories, each middle trajectory must be fully defined in the period of time $[0,\pi]$, while $\tau_1$ must be defined in $[t_{initial},\pi]$ and $\tau_n$ must be defined in $[0, t_{final}]$.

\begin{description}

\item[Pattern -]{If a patch is a spatio-temporal cube (or any other right prism, depending on the type of polygon used as its area, then a pattern could be defined as one lateral side of the \note{cube (or right prism).} Specifically, it is a rectangle whose base is one of the edges of the polygonal area (we define $I$ as this two dimensional vector), and its height is equal to the period. These patterns also include the sets of boundary control points. We divide this set evenly into two subsets: Input and Output. The Input set contains the boundary control points where exogenous agents begin their trajectories; we call these Entry Points. Conversely the elements of Output are called Exit Points. They establish the position in time and space that the exogenous agents finish their paths. Formally defined, a patch P is:
$$ P = {l, p_i, I_i [p_i, t_i], O_j[p_j, t_j]}$$
We populate virtual environments by sticking patches together. Thus, we have to ensure continuity between trajectories for exogenous agents passing through two contiguous patches. This means that two adjacent patches must \note{have a similar pattern on the side they share}. The vector $l$ \claudia{Is this vector $l$ or $I$?, please check } and period must be equivalent and the sets of Input and Output are exchanged. If we have $P_1={l, pi, I [p_1,t_1], O[p_2,t_2]}$ and $P_2={lÕ, piÕ, IÕ[pÕ_2, tÕ_2], OÕ[pÕ_1, tÕ_1]}$, then, in order to satisfy $C^0$ continuity we must ensure: 
$$ l=lÕ, pi=piÕ, p_1=pÕ_1, t_1=tÕ_1, p_2=pÕ_2, t_2=tÕ_2.$$
We then say $P_1$ is the mirror pattern of $P_2$. In the animation, this will be seen as an agent going from one patch to an adjacent one. 
If the area of a patch is a square, the patch defines 4 patterns, one for each of its sides. Patterns defined by a patch have the property that the sum of the cardinality of all the Inputs is the same as the sum of the cardinality of all Outputs. We call this the parity condition: $\sum(|Inputs|)= \sum(|Outputs|)$.

A patch defines a set of Patterns, and conversely, a set of patterns satisfying the parity condition, having the same period, and whose vectors define a convez polygonal area, can be used to create a patch. 
 }

\end{description}

\subsection{Overview}
\label{method:overview}

The objective is, given a set of patterns, we want to construct a patch.
This process has three main steps:
\begin{enumerate}
  \item Make a matching between the elements in the Input and Output sets contained within a patch. In this step, we connect Entry to Exit Points based on a scoring function. This function tries to keep agents close to their prefered speed while at the same time avoiding connections to similar patterns, thus reducing unwanted u-turns.  The input for this function is a set of patterns and the output is a set of piecewise linear trajectories connecting the entry and exit points.
  \item Create collision free trajectories for these pairings. We start with simple line trajectories and start bending them until they are collision free. Points lying at the borders, i.e. the Entry and Exit points, are hard restraints and can never be moved.
  \item Smoothing trajectories (if needed).  Last, we use splines to minimize the hard turns. We make sure the new trajectories stay close to the original ones, lest we create new collisions.
\end{enumerate}

\note{Problem : is to compute internal trajectories that join all boundary conditions with conitnuous and believable motion trajectories. 

2 steps: 
 - step 1: connect waypoints
INPUT first boudnary conditions are ``alone'' in patches $\rightarrow$ associate/connect waypoints
 them 
OUTPUT : initial trajectories (piecewise linear trajs, possibly colliding, with ``good'' properties that we will define later on)

 - step 2: optimize intial trajectories by moving control points to remove collisions
    INPUIT : initial trazjectories
      OUTPUT : colliision trajectories, still enforcing boundary conditions
      
- step 3 is smoothing
}       


\subsection{Connecting Boundary Control Points}

The first step to this algorithm is to match all the entry and exit points.  To do this, we have to measure how good or bad a match is. Intuitively, there are some better matches than others, Judging by sight, trajectories passing near the center of the patch look better that the ones staying close to the borders. We can consider some other aspects too, like how close the speed needed for the agent to go from the Entry Point to the Exit Point is to comfort speed. We use a comfort speed of $1.33~m/s$ which is the normal walking speed of humans in an unconstrained environment.

For a square patch, we prefer to match points with points on the opposite pattern. Then the points on the contiguous pattern and finally, the points that are in the same pattern. If there are multiple options on the same pattern we choose the point whose associated trajectory is closest to comfort speed.

To solve this matching problem, we make use of the Gale-Shapley algorithm~\cite{gale1962college} (see Algorithm~\ref{alg:stable-matching}), commonly referred to as the algorithm to solve the stable marriage problem.  This algorithm assures that at the end, if we have Alice engaged to Bob and Carol engaged to Dave, it is not possible for Alice to prefer Dave and Dave to prefer Alice. We call that a stable matching.  

This pseudocode demonstrates the Gale-Shapley algorithm in relation to two equal lists of men and women who are being matched for marriage. However the algorithm generalizes to any matchable objects, which in our case is entry and exit points.

%%-------------------------------------------------------------------
%% The Stable Matching Algorithm by Gale-Shapley
%%-------------------------------------------------------------------
\begin{algorithm}[t]
Put here the algorith of stablematching
\caption{Stable Matching Algorithm}
\label{alg:stable-matching}
\end{algorithm}
%%-------------------------------------------------------------------
%% The Stable Matching Algorithm by Gale-Shapley
%%-------------------------------------------------------------------


All we need in order to use this algorithm is a to generate preferences for entry and exit points. We do this with the following steps:
\begin{enumerate}
  \item Find the speed it would take to travel from an Entry Point to an Exit Point.  Let’s assume $(p_1, t_1)$ is position and time of the Entry Point and $(p_2,t_2)$ the equivalent of the Exit point. Speed is $d/t$ where $d=|p_1-p_2|$ and $time=t_2-t_1$ in case $t_2>t_1$. Otherwise, $time=period+t_2-t_1$. More details on why we take this time will be given later when we create the initial set of trajectories.
  \item Now, we assign each pair of points a number between $0$ and $\pi/2$, where $0$ represents maximum closeness to comfort speed with $arctan(|comfort speed -speed|)$.
  \item We add penalties for points being in the same patch, for those points, we add $4$. For points lying in the contiguous pattern we also add a smaller penalty, $2$.
  \item We sort each list.
\end{enumerate}
\panayiotis{The steps above need editing}    
 
We will have a list similar to this for each entry and exit point, we call this list the proposal list (see Table~\ref{tab:proposal-list}).

%%-------------------------------------------------------------------
%% The Proposal List table
%%-------------------------------------------------------------------
\begin{table}[b]
	\caption{Proposal List}
	\begin{tabular}{|c|c|}
		\multicolumn{2}{c}{Rankings of preferred}\\
		\multicolumn{2}{c}{partners for Entry Point A}\\
		\hline
		Preference	& Exit Point\\
		\hline\hline
		$0.34$		&	B\\
		$1.3$		&	C\\
		$2.3$		&	A\\
		$2.4$		&	E\\
		$4.5$		&	D\\
		$4.6$		&	F\\
		\hline
		\end{tabular}
	\label{tab:proposal-list}
\end{table}
%%-------------------------------------------------------------------
%% The Proposal List table
%%-------------------------------------------------------------------


Exit Points F and D lie in the same pattern as Entry Point A, so they receive a higher number.
After this, we use the stable matching algorithm mentioned above.

Every two points that remained engaged at the end of the algorithm become a pair.
The last step is to create the initial batch of trajectories. We start by trying to connect the points with a straight line. We do something special when a line tries to travel backwards in time, i.e. $t_2<t_1$. For these cases we split the initial trajectory in two. One going from $t_1$ to period $\pi$, another one going from $0$ to $t_2$.  The positions of these new control points are in the same straight line, taken in such a way that the speed is the same going from $t_1$ to $\pi$ and from $0$ to $t_2$. We use the same method if the trajectory is moving at unrealistically fast speeds.

We make further adjustments in the initial trajectory in some special cases. For agents traveling only over the edge, we add a control point near the center of the patch. For agents moving slowly we add a control point with same position, but different time, thus making the agent do a full stop (as if pausing to look around), after a few moments it continues its journey with a better speed.

\devin{The output of this function is a set of trajectories. Collisions are probably still present in the trajectories at this point.}
 

\note{
- INPUT OUTPUT objective

- when you connect two boundary conditions, you connect two spation temporal waypoints. This means that you determine this way where characters enter, where they exit patches and the speed between waypoints. 

- we can define what is a “good” connection: avoid half turn, avoid extreme speeds. 

- we define an objective function, we solve this using the stable marriage problem. 

- reminder of 2009 paper - you explain the specific case of splitting trajectories. 

-  you provide pseudo algo for this,  

 - you define all the variables/parameters you use. 
 
summarize what you get as an aoutput, and what is the next step.
}



\subsection{Removing Collisions}
\label{sec:method:remove-collisions}

\panayiotis{Make sure for all the equation that the correct symbols are inserted: bold for vectors, normal fonts for scalars, etc.}

We are given a set of trajectories within a patch consisting of both movable and boundary control points. What we expect in return is modified trajectories that have maintained their spatiotemporal entrance and exit points while removing all collisions throughout the entire period of the patch. Our objective is to use these patches in larger crowd simulations of people. We would like to create trajectories that could represent human motion. We focus on creating collision free motion since obvious collisions in simulations greatly reduces the realism of the animation.





Given two trajectories you can find the distance between them at any moment in time. The shortest distance between trajectories is the minimum of all these distances computed over the period of the patch. To compute the minimum distance between two trajectories we find the minimum distance between all the segments of the trajectories and take the minimum of the minimums as our final answer. When looking at two segments we find the intersection of the time intervals. If the intersection is not empty, we find the minimum distance. We call the start and end time of this intersection $t_0$ and $t_1$ respectively.

Each one of those segments represent a moving agent with an initial position $p_0$ and $p_1$ with velocities $v_0$ and $v_1$ moving in the time interval $[t_0,t_1]$. 

We can then define the distance at a certain time between the two segments with the following equation.

\begin{equation}
	d(t) = || (p_0+v_0*t) - (p_1+v_1*t) ||
	\label{eqn:distance}
\end{equation}

For simplicity we say $w = p_0-p_1$ and $dv = v_0-v_1$, so then,

\begin{equation}
	d(t) = || w + dv*t ||
	\label{eqn:distance_simple}
\end{equation}



We are looking for the minimum so we solve for $t$ when when the derivative equals zero.
\begin{equation}
	t_c = (-w . dv) / || dv ||^2
\end{equation}

With $t_c$, the time at which the two line segments are closest we can easily calculate the position on each of those segments, and thus the distance between them. If the time is outside the bounds of the segment we check the endpoints of the line segment for collision.


%%-------------------------------------------------------------------
%% Removing collisions figure
%%-------------------------------------------------------------------
\begin{figure*}[t]
	\begin{center}
	\includegraphics[width=0.3\linewidth]{./images/collision-2D-example-with-collision.png}
	\includegraphics[width=0.3\linewidth]{./images/collision-2D-example-without-collision.png}
	\includegraphics[width=0.3\linewidth]{./images/collision-2D-example-overlay.png}
	\caption{
		\textbf{\textbf{Collision removal}}
	}
	\label{fig:collision-removal}
	\end{center}
\end{figure*}
%%-------------------------------------------------------------------
%% Removing collisions figure
%%-------------------------------------------------------------------


We compute a minimum distance between each pair of trajectories. We store each value in a minimum distance matrix M. The position in the matrix corresponds to the trajectory ID. So the value at M(a, b) would be the minimum distance from trajectory a to trajectory b. It’s good to note that this value will be the same as M(b,a). Furthermore M(x,x) will always be zero. These facts can be used to reduce computation while filling out the minimum distance matrix.

Our algorithm creates collision free trajectories by adding and modifying control points. We can guarantee this by looking at the minimum distance matrix. If every value in the matrix is above some threshold then we know that for the entire period of the patch no two agents come closer than that threshold. So if we make that threshold equal to the sum of the radii being compared, those agents will never touch.


pseudo-code
compute minimum distance matrix
while(there exists at least one distance less than its threshold):
    find smallest value in that matrix, look at the two trajectories that correspond to that value
update both trajectories to either move or add a control point
update minimum distance matrix

We begin by computing the minimum distance matrix. Then while collisions still exist we find the smallest value in the minimum distance matrix. From that we find the corresponding trajectories and a point of closest approach for each trajectory. We then find an updated position for each of these points.

To find the the updated position of a new point we add a correction force to its current position.

New P1 = old P1 + Correction Force on P1

The correction force is found based on the radius of the two agents, the position of the closest point, a constant weight to help reduce speed artifacts and prevent agents from leaving the bounds the patch, and a small random noise rotation to help prevent infinite loops.

Correction Force on P1 = Rotation Matrix * (p1 - p2).normalized * threshold * weightOfP1

NOTE: threshold = radius1 + radius2. In our implementation r1 == r2 so we just had a constant threshold

Rotation Matrix rotation of plus or minus some small angle. 0.5 radians ~ 28.65°

weightOfP1 = { speed2 / (speed1 + speed2) if the point won’t go outside the patch}
               { 0                        if the force would result in the point going outside the patch}

The calculations for P2 are symmetric. Once we have this new point for the trajectory we check to see if there is already a control point within a small time interval of the new point. If there is we move that control point to this new position in space and time. Otherwise we add a control 
point in the trajectory at this new position. Finally we update the minimum distance matrix. We do not need to recheck all the distances in the matrix, only the ones that interact with the trajectory we have modified.

We find that in many situations this algorithm converges quickly and produces collision free trajectories. However there are still situations where it converges slowly or even gets stuck in an infinite loop.

\subsection{Smoothing}

Smoothing:
We have obtained some collision free trajectories, but they may have a jerky trajectory, so we need a final the step to smooth them. We need to take special care of how we do this, we don’t want the trajectories to change in such a way that they make new collisions. A simple approach is to use cubic splines. Cubic splines connects every pair of points in a trajectory with a polynomial function of degree 3

 S(x)=a+bx+ cx^2+ dx^3
In total, we will need to find the coefficients a, b, c, and d for every segment we have in our trajectory. Those coefficients are determined by continuity C^1 restrictions: 

For every spline associated with a trajectory between point p1=(x1,y1,t1) and p2=(x2,y2,t2), the spline must pass through those same points, that is, S(t1)=(x1,y1) and S(t2)=(x2,y2).

For every two contiguous splines S1 and S2, for the common point they share p, the velocity must be equivalent, that is,  S1’(p)=S2’(p).
  
This restrictions can be accommodated in a such way that they form a system of linear equations that can be solved using Cholesky decomposition.

We can not apply directly this method using our current control points. That results in trajectories that vary too much from the original, thus they may end up creating new collisions. To make the spline more similar to the original trajectory, we add new virtual control points sampled uniformly in the linear segments of the trajectories. We call these tacks. These tacks help fix the splines, because they will now pass through the control points and the tacks. Note that the more tacks we put, the closer the spline will fit to the original path.

After that, we compute the coefficients to create the splines and resample along the spline to get new control points. The new trajectory will still be composed of line segments, but since they are smaller, and following closely the path of a cubic function, to the naked eye they will look like curves. The finer the sample, the more it will look like a smooth path.

For optimization purposes, we choose a different sampling method. The trajectories are relatively straight in the middle of the the segments and have higher curvature near control points. For that reason, we take more samples around inflexion points (old control points) than far from them. These samples become the new control points that define the trajectory.

There may be cases, even with a healthy number of tacks, that the splines still vary too much from the original trajectory. We define a threshold based on the same threshold of collision to know how far a way a point can be moved. For these cases where the new control point surpasses the threshold, we simply don’t add it to the set of new control points.  There may be extreme cases (for example, due to too a bad sampling of the tacks at the beginning), where the spline has extreme curves that are very different from our initial trajectory. In those extreme cases most of the new control points would not be added and the new smooth trajectory would end up being very similar to the original one.




Maybe next paragraph goes better in discussion?
Having splines for trajectories is better than having simple straight lines, but we know humans don’t  follow either of them when walking,  so other methods can be tried to improve this initial approach.



 - input : piecewiselinear trajectories. output : a certain kind of splines. Objective: remove sharp changes in speed and orientation
 - should be short. 


